{
    "sourceFile": "renderer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1767806374675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767846388661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,9 +92,9 @@\n \r\n   // Filter by search text\r\n   let displayEntries = entries\r\n   if (searchText) {\r\n-    displayEntries = displayEntries.filter(entry => {\r\n+    displayEntries = displayEntries.filter((entry) => {\r\n       const name = (entry.task_name || '').toLowerCase()\r\n       return name.includes(searchText)\r\n     })\r\n   }\r\n@@ -254,9 +254,9 @@\n     if (currentTaskId) {\r\n       const current = entries.find((e) => e.task_id === currentTaskId)\r\n       const taskName = current?.task_name || currentEntry?.task_name || 'Unknown task'\r\n       statusEl.innerHTML = `<span class=\"current\"><button class=\"status-stop-btn\" id=\"status-stop-btn\" title=\"Stop timer\">⏹</button>${taskName}</span>`\r\n-      \r\n+\r\n       // Attach click handler to status stop button\r\n       const statusStopBtn = document.getElementById('status-stop-btn')\r\n       if (statusStopBtn) {\r\n         statusStopBtn.addEventListener('click', async () => {\r\n"
                },
                {
                    "date": 1768873903666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -220,11 +220,11 @@\n       await window.clickup.stopTimer()\r\n       currentTaskId = null\r\n     } else {\r\n       // Find the most recent entry for this task to get billable status\r\n-      const taskEntries = entries.filter(e => e.task_id === taskId)\r\n+      const taskEntries = entries.filter((e) => e.task_id === taskId)\r\n       const billable = taskEntries.length > 0 ? taskEntries[0].billable : true\r\n-      \r\n+\r\n       await window.clickup.startTask(taskId, billable)\r\n       currentTaskId = taskId\r\n     }\r\n     await refreshEntries()\r\n"
                }
            ],
            "date": 1767806374675,
            "name": "Commit-0",
            "content": "const taskListEl = document.getElementById('task-list')\r\nconst statusEl = document.getElementById('status')\r\nconst refreshTimerEl = document.getElementById('refresh-timer')\r\nconst uniqueToggle = document.getElementById('unique-toggle')\r\n\r\nlet entries = []\r\nlet currentTaskId = null\r\nlet refreshInterval = null\r\nlet countdownInterval = null\r\nlet nextRefresh = 0\r\nlet hideDailyDuplicates = false\r\n\r\nconst REFRESH_MS = 3 * 60 * 1000 // 3 minutes\r\n\r\n// Toggle handler\r\nuniqueToggle.addEventListener('click', () => {\r\n  hideDailyDuplicates = !hideDailyDuplicates\r\n  uniqueToggle.classList.toggle('active', hideDailyDuplicates)\r\n  renderTasks()\r\n})\r\n\r\nfunction formatTime(ms) {\r\n  if (!ms) return '--:--'\r\n  const date = new Date(ms)\r\n  return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false })\r\n}\r\n\r\nfunction formatDuration(ms) {\r\n  if (!ms || ms < 0) return '--:--:--'\r\n  const totalSec = Math.floor(ms / 1000)\r\n  const hours = Math.floor(totalSec / 3600)\r\n  const minutes = Math.floor((totalSec % 3600) / 60)\r\n  const seconds = totalSec % 60\r\n  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`\r\n}\r\n\r\nfunction formatCountdown(ms) {\r\n  if (ms <= 0) return 'now'\r\n  const sec = Math.ceil(ms / 1000)\r\n  const min = Math.floor(sec / 60)\r\n  const s = sec % 60\r\n  return min > 0 ? `${min}m ${s}s` : `${s}s`\r\n}\r\n\r\nfunction getPSTDateString(ms) {\r\n  if (!ms) return ''\r\n  const date = new Date(ms)\r\n  // Format in PST (America/Los_Angeles)\r\n  return date.toLocaleDateString('en-US', {\r\n    timeZone: 'America/Los_Angeles',\r\n    weekday: 'short',\r\n    month: 'short',\r\n    day: 'numeric'\r\n  })\r\n}\r\n\r\nfunction updateCountdown() {\r\n  const remaining = nextRefresh - Date.now()\r\n  refreshTimerEl.textContent = `Refresh in ${formatCountdown(remaining)}`\r\n}\r\n\r\nfunction renderTasks() {\r\n  if (!entries.length) {\r\n    taskListEl.innerHTML = '<div class=\"loading\">No time entries found</div>'\r\n    return\r\n  }\r\n\r\n  // Filter to unique tasks per day if toggle is on\r\n  let displayEntries = entries\r\n  if (hideDailyDuplicates) {\r\n    const seenPerDay = new Map() // day -> Set of task_ids\r\n    displayEntries = entries.filter(entry => {\r\n      const day = getPSTDateString(entry.startMs)\r\n      if (!seenPerDay.has(day)) {\r\n        seenPerDay.set(day, new Set())\r\n      }\r\n      const daySet = seenPerDay.get(day)\r\n      if (daySet.has(entry.task_id)) {\r\n        return false // duplicate for this day\r\n      }\r\n      daySet.add(entry.task_id)\r\n      return true\r\n    })\r\n  }\r\n\r\n  let lastDay = null\r\n  let html = ''\r\n\r\n  displayEntries.forEach(entry => {\r\n    const entryDay = getPSTDateString(entry.startMs)\r\n    \r\n    // Add day separator if day changed\r\n    if (entryDay && entryDay !== lastDay) {\r\n      html += `<div class=\"day-separator\"><span class=\"day-label\">${entryDay}</span></div>`\r\n      lastDay = entryDay\r\n    }\r\n\r\n    const isRunning = entry.isRunning || entry.task_id === currentTaskId\r\n    const btnClass = isRunning ? 'stop' : 'start'\r\n    const btnIcon = isRunning ? '⏹' : '▶'\r\n    const itemClass = isRunning ? 'task-item running' : 'task-item'\r\n    \r\n    const startTime = formatTime(entry.startMs)\r\n    const endTime = entry.isRunning ? 'running' : formatTime(entry.endMs)\r\n    const lasted = entry.isRunning ? 'tracking...' : formatDuration(entry.duration)\r\n    \r\n    html += `\r\n      <div class=\"${itemClass}\" data-task-id=\"${entry.task_id}\" data-entry-id=\"${entry.entry_id}\">\r\n        <button class=\"task-btn ${btnClass}\" data-task-id=\"${entry.task_id}\" data-running=\"${isRunning}\">\r\n          ${btnIcon}\r\n        </button>\r\n        <div class=\"task-content\">\r\n          <div class=\"task-name\" title=\"${entry.task_name || 'Unknown task'}\">${entry.task_name || 'Unknown task'}</div>\r\n          <div class=\"task-time\">\r\n            ${startTime} → ${endTime} • ${lasted}\r\n          </div>\r\n        </div>\r\n        <button class=\"task-delete\" data-entry-id=\"${entry.entry_id}\" title=\"Delete entry\">✕</button>\r\n      </div>\r\n    `\r\n  })\r\n\r\n  taskListEl.innerHTML = html\r\n\r\n  // Attach click handlers\r\n  taskListEl.querySelectorAll('.task-btn').forEach(btn => {\r\n    btn.addEventListener('click', handleTaskClick)\r\n  })\r\n\r\n  // Attach copy handlers to task content\r\n  taskListEl.querySelectorAll('.task-content').forEach(content => {\r\n    content.addEventListener('click', handleCopyTaskUrl)\r\n  })\r\n\r\n  // Attach delete handlers\r\n  taskListEl.querySelectorAll('.task-delete').forEach(btn => {\r\n    btn.addEventListener('click', handleDeleteEntry)\r\n  })\r\n}\r\n\r\nasync function handleDeleteEntry(e) {\r\n  const btn = e.currentTarget\r\n  const entryId = btn.dataset.entryId\r\n  if (!entryId) return\r\n\r\n  btn.disabled = true\r\n  btn.textContent = '...'\r\n\r\n  try {\r\n    await window.clickup.deleteEntry(entryId)\r\n    await refreshEntries()\r\n  } catch (err) {\r\n    statusEl.textContent = `Error: ${err.message}`\r\n    statusEl.style.color = '#D0BCFF'\r\n  }\r\n}\r\n\r\nasync function handleCopyTaskUrl(e) {\r\n  const taskItem = e.currentTarget.closest('.task-item')\r\n  const taskId = taskItem?.dataset?.taskId\r\n  if (!taskId) return\r\n\r\n  const url = `https://app.clickup.com/t/${taskId}`\r\n  \r\n  try {\r\n    await navigator.clipboard.writeText(url)\r\n    // Show copied feedback\r\n    taskItem.classList.add('copied')\r\n    setTimeout(() => taskItem.classList.remove('copied'), 1500)\r\n  } catch (err) {\r\n    console.error('Failed to copy:', err)\r\n  }\r\n}\r\n\r\nasync function handleTaskClick(e) {\r\n  const btn = e.currentTarget\r\n  const taskId = btn.dataset.taskId\r\n  const isRunning = btn.dataset.running === 'true'\r\n\r\n  btn.disabled = true\r\n  btn.textContent = '...'\r\n\r\n  try {\r\n    if (isRunning) {\r\n      await window.clickup.stopTimer()\r\n      currentTaskId = null\r\n    } else {\r\n      await window.clickup.startTask(taskId)\r\n      currentTaskId = taskId\r\n    }\r\n    await refreshEntries()\r\n  } catch (err) {\r\n    statusEl.textContent = `Error: ${err.message}`\r\n    statusEl.style.color = '#D0BCFF'\r\n  }\r\n}\r\n\r\nasync function refreshEntries() {\r\n  try {\r\n    statusEl.textContent = 'Refreshing...'\r\n    statusEl.style.color = '#CAC4D0'\r\n    \r\n    const [entriesData, currentEntry] = await Promise.all([\r\n      window.clickup.getEntries(),\r\n      window.clickup.getCurrentEntry()\r\n    ])\r\n    \r\n    entries = entriesData || []\r\n    currentTaskId = currentEntry?.task_id || null\r\n    \r\n    // Mark current entry as running\r\n    entries.forEach(e => {\r\n      if (e.task_id === currentTaskId) {\r\n        e.isRunning = true\r\n      }\r\n    })\r\n    \r\n    renderTasks()\r\n    \r\n    if (currentTaskId) {\r\n      const current = entries.find(e => e.task_id === currentTaskId)\r\n      statusEl.innerHTML = `<span class=\"current\">▶ ${current?.task_name || 'Timer running'}</span>`\r\n    } else {\r\n      statusEl.textContent = 'No timer running'\r\n    }\r\n    statusEl.style.color = ''\r\n    \r\n    // Reset refresh timer\r\n    nextRefresh = Date.now() + REFRESH_MS\r\n  } catch (err) {\r\n    taskListEl.innerHTML = `<div class=\"error\">Error: ${err.message}</div>`\r\n    statusEl.textContent = 'Error loading entries'\r\n    statusEl.style.color = '#D0BCFF'\r\n  }\r\n}\r\n\r\n// Handle status updates from global hotkey\r\nwindow.clickup.onStatus(async (r) => {\r\n  if (r.action === 'started') {\r\n    currentTaskId = r.task_id\r\n  } else if (r.action === 'stopped') {\r\n    currentTaskId = null\r\n  }\r\n  await refreshEntries()\r\n})\r\n\r\n// Initial load\r\nrefreshEntries()\r\n\r\n// Auto-refresh every 3 minutes\r\nrefreshInterval = setInterval(refreshEntries, REFRESH_MS)\r\n\r\n// Update countdown every second\r\ncountdownInterval = setInterval(updateCountdown, 1000)\r\nnextRefresh = Date.now() + REFRESH_MS\r\n"
        }
    ]
}